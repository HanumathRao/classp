class Expression {
  %parseable;
}

class Variable: Expression {
  identifier id;
  syntax(id);
}

class IntegerLiteral: Expression {
  int val;
  syntax(val);
}


class Unop: Expression {
  Expression arg1;
}

class Binop: Expression {
  Expression arg1;
  Expression arg2;
}

class Trinop: Expression {
  Expression arg1;
  Expression arg2;
  Expression arg3;
}

class OrOp: Binop {
  syntax(arg1 'or' arg2) %left 1;
}

class AndOp: Binop {
  syntax(arg1 'and' arg2) %left 2;
}

class NotOp: Binop {
  syntax('not' arg1) %left 3;
}

class EqOp: Binop {
  syntax(arg1 '=' arg2) %nassoc 4;
}

class NeOp: Binop {
  syntax(arg1 '!=' arg2) %nassoc 4;
}

class LtOp: Binop {
  syntax(arg1 '<' arg2) %nassoc 4;
}

class LeOp: Binop {
  syntax(arg1 '<=' arg2) %nassoc 4;
}

class GtOp: Binop {
  syntax(arg1 '>' arg2) %nassoc 4;
}

class GeOp: Binop {
  syntax(arg1 '>=' arg2) %nassoc 4;
}

class BetweenOp: Trinop {
  syntax(arg1 'between' arg2 'and' arg3) %nassoc 4;
}

class PlusOp: Binop {
  syntax(arg1 '+' arg2) %left 5;
}

class MinusOp: Binop {
  syntax(arg1 '-' arg2) %left 5;
}

class TimesOp: Binop {
  syntax(arg1 '*' arg2) %left 6;
}

class DivideOp: Binop {
  syntax(arg1 '/' arg2) %left 6;
}

class NegateOp: Unop {
  syntax('-' arg1) %left 7;
}

class FunctionCall: Expression {
  identifier functionName;
  Expression args[];
  syntax(functionName '(' (args*',') ')');
}
