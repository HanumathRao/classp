class Expression {}

class Variable: Expression {
  identrifier id;
  syntax(id);
}

class IntegerLiteral: Expression {
  int val;
  syntax(val);
}

class CaseExpression: Expression {
  Expression testExpr default true;
  Expression conditions[];
  Expression results[];
  Expression elseResult syntax('else' elseResult|);
  syntax('case' (testExpr|) ('when' conditions 'then' results*) elseResult);
}

class Invocation: Expression {
  Expression args[];
}

class OrOp: Invocation {
  syntax(args[1] 'or' args[2]) %left 1;
}

class AndOp: Invocation {
  syntax(args[1] 'and' args[2]) %left 2;
}

class NotOp: Invocation {
  syntax('not' args[1]) %left 3;
}

class EqOp: Invocation {
  syntax(args[1] '=' args[2]) %nassoc 4;
}

class NeOp: Invocation {
  syntax(args[1] '!=' args[2]) %nassoc 4;
}

class LtOp: Invocation {
  syntax(args[1] '<' args[2]) %nassoc 4;
}

class LeOp: Invocation {
  syntax(args[1] '<=' args[2]) %nassoc 4;
}

class GtOp: Invocation {
  syntax(args[1] '>' args[2]) %nassoc 4;
}

class GeOp: Invocation {
  syntax(args[1] '>=' args[2]) %nassoc 4;
}

class BetweenOp: Invocation {
  syntax(args[1] 'between' args[2] 'and' args[3]) %nassoc 4;
}

class PlusOp: Invocation {
  syntax(args[1] '+' args[2]) %left 5;
}

class MinusOp: Invocation {
  syntax(args[1] '-' args[2]) %left 5;
}

class TimesOp: Invocation {
  syntax(args[1] '*' args[2]) %left 6;
}

class DivideOp: Invocation {
  syntax(args[1] '/' args[2]) %left 6;
}

class NegateOp: Invocation {
  syntax('-' args[1]) %left 7;
}

class FunctionCall: Invocation {
  identifier functionName;
  syntax(functionName '(' (args*',') ')');
}
