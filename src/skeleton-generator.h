/* THIS IS AN AUTOMATICALLY GENERATED FILE. DO NOT EDIT IT. */

void ParserBase::PrintHFile(ostream& out) {
  out << 
      "/* BEGIN HEADER */\n"
      "#ifndef " << ModuleNameUpper() << "_INCLUDE_\n"
      "#define " << ModuleNameUpper() << "_INCLUDE_\n"
      "\n"
      "#include <assert.h>\n"
      "#include <unordered_map>\n"
      "#include <utility>\n"
      "\n"
      "#include \"classp.h\"\n"
      "\n"
      "// Include files generated by bison\n"
      "#include \"" << ModuleName() << ".yacc.hh\"\n"
      "#include \"location.hh\"\n"
      "#include \"position.hh\"\n"
      "\n"
      "namespace " << NamespaceName() << " {\n"
      "using std::istream;\n"
      "using std::ostream;\n"
      "using classp::classpPrint;\n"
      "using classp::classpFormat;\n"
      "using classp::AttributeMap;\n"
      "\n"
      "// Location and state information from the parser.\n"
      "typedef location ParseState;\n"
      "\n"
      "class AstNode;\n"
      "/* BEGIN FORWARD DECLARATIONS */\n"
      ;
  PrintForwardDeclarations(out);
  out <<
      "/* END FORWARD DECLARATIONS */\n"
      "\n"
      "// Base class for " << NamespaceName() << " AST nodes\n"
      "class AstNode : public classp::ClasspNode {\n"
      " public:\n"
      "  string className() override { return \"AstNode\"; }\n"
      "  AstNode(ParseState parseState)\n"
      "    : parseState(parseState) {\n"
      "    }\n"
      "\n"
      "  // Write out a bracketed form of this AST from the declared syntax.\n"
      "  virtual void bracketFormat(std::ostream& out, AstNode* self) {\n"
      "    assert(false);\n"
      "  }\n"
      "\n"
      "  ParseState parseState;\n"
      "};\n"
      "\n"
      "/* BEGIN CLASS DEFINITIONS */\n"
      ;
  PrintClassDefinitions(out);
  out <<
      "/* END CLASS DEFINITIONS */\n"
      "\n"
      "}  // namespace " << NamespaceName() << "\n"
      "#endif // " << ModuleNameUpper() << "_INCLUDE_\n"
      "\n"
      "/* END HEADER */\n";
}

void ParserBase::PrintParser(ostream& out) {
  out <<
      "/* BEGIN PARSER */\n"
      "%code requires {\n"
      "\n"
      "#include <string>\n"
      "using std::string;\n"
      "#include <vector>\n"
      "using std::vector;\n"
      "\n"
      "/* BEGIN CODE PREFIX */\n"
      ;
  PrintCodePrefix(out);
  out <<
      "/* END CODE PREFIX */\n"
      "\n"
      "#include \"classp.h\"\n"
      "using classp::AttributeMap;\n"
      "typedef string identifier;\n"
      "\n"
      "namespace " << NamespaceName() << " {\n"
      "class ParseDriver;\n"
      "class AstNode;\n"
      "/* BEGIN FORWARD DECLARATIONS */\n"
      ;
  PrintForwardDeclarations(out);
  out <<
      "/* END FORWARD DECLARATIONS */\n"
      "}\n"
      "\n"
      "}\n"
      "\n"
      "%require \"3.0.2\"\n"
      "%defines\n"
      "%define api.value.type variant\n"
      "%define \"parser_class_name\" {YYParser}\n"
      "%error-verbose\n"
      "%lex-param {" << NamespaceName() << "::ParseDriver* parser}\n"
      "%locations\n"
      "%define api.namespace {" << NamespaceName() << "}\n"
      "%parse-param {" << NamespaceName() << "::ParseDriver* parser}\n"
      "%parse-param {" << NamespaceName() << "::AstNode** result}\n"
      "%define api.token.constructor\n"
      "%skeleton \"lalr1.cc\"\n"
      "\n"
      "%initial-action {\n"
      "}\n"
      "\n"
      "%token TOK_EOF 0              \"end of file\"\n"
      "\n"
      "/* BEGIN GENERATED TOKEN DECLARATIONS */\n"
      ;
  PrintTokenDeclarations(out);
  out <<
      "/* END GENERATED TOKEN DECLARATIONS */\n"
      "\n"
      "%token TOK_BOOL   \"boolean literal\"\n"
      "%token TOK_IDENTIFIER         \"identifier\"\n"
      "%token TOK_INT64    \"integer literal\"\n"
      "%token TOK_STRING_LITERAL     \"string literal\"\n"
      "\n"
      "\n"
      "/* BEGIN NONTERMINAL TYPES */\n"
      ;
  PrintNonterminalTypes(out);
  out <<
      "/* END NONTERMINAL TYPES */\n"
      "\n"
      "%type <bool> TOK_BOOL\n"
      "%type <int64_t> TOK_INT64\n"
      "%type <string>  TOK_IDENTIFIER\n"
      "%type <string>  TOK_STRING_LITERAL\n"
      "\n"
      "%code {\n"
      "\n"
      "#include \"" << ModuleName() << ".yacc.hh\"\n"
      "#include \"" << ModuleName() << ".h\"\n"
      "\n"
      "namespace " << NamespaceName() << " {\n"
      "\n"
      "YYParser::symbol_type yylex(ParseDriver* parser);\n"
      "\n"
      "}  // namespace " << NamespaceName() << "\n"
      "\n"
      "}\n"
      "\n"
      "\n"
      "%start start\n"
      "\n"
      "%%\n"
      "\n"
      "start\n"
      "/* BEGIN PARSEABLE */\n"
      ;
  PrintParseableClassRules(out);
  out <<
      "/* END PARSEABLE */\n"
      "  ;\n"
      "\n"
      "/* BEGIN PRODUCTIONS */\n"
      ;
  PrintProductions(out);
  out <<
      "/* END PRODUCTIONS */\n"
      "\n"
      "%%\n"
      "\n"
      "#include <sstream>\n"
      "\n"
      "namespace " << NamespaceName() << " {\n"
      "\n"
      "using std::istream;\n"
      "using std::ostream;\n"
      "using std::stringstream;\n"
      "\n"
      "AstNode* parse(istream& input, ostream& errors);\n"
      "\n"
      "/* BEGIN METHOD DEFINITIONS */\n"
      ;
  PrintMethodDefinitioms(out);
  out <<
      "/* END METHOD DEFINITIONS */\n"
      "\n"
      "#ifdef PARSER_TEST\n"
      "\n"
      "void ParseAndPrint(istream& input, ostream& out) {\n"
      "/* BEGIN PARSE PARSEABLE */\n"
      ;
  PrintParseParseable(out);
  out <<
      "/* END PARSE PARSEABLE */\n"
      "  if (result) {\n"
      "    out << \"Succeeded:\\n\";\n"
      "    result->format(out);\n"
      "    out << \"\\n\";\n"
      "  } else {\n"
      "    out << \"Parse failed.\\n\";\n"
      "  }\n"
      "}\n"
      "\n"
      "// These constants never a legal output from AstParser::print()\n"
      "const char kSucceed[] = \"!succeed!\";\n"
      "const char kFail[] = \"!fail!\";\n"
      "const char kPrint[] = \"!print!\";\n"
      "\n"
      "// Runs the parser in the given sample and compares the result to\n"
      "// expected_result which can be nullptr to indicate that the parse should fail.\n"
      "// With no second argument, this just prints the result. Returns 1 if the parse\n"
      "// failed and was not expected to, or if the result is different from the\n"
      "// expected result, otherwise returns 0.\n"
      "template<class T>\n"
      "int ParseSample(const char* sample, const char* expected_result = kPrint) {\n"
      "  stringstream input(sample);\n"
      "  stringstream errors;\n"
      "  std::cout << \"parsing '\" << sample << \"':\\n\";\n"
      "  AstNode* result = T::parse(input, errors);\n"
      "  if (result) {\n"
      "    std::cout << \"SUCCEEDS\";\n"
      "    if (expected_result == kPrint) {\n"
      "      std::cout << \": \";\n"
      "      result->print(std::cout);\n"
      "    } else if (expected_result == kFail) {\n"
      "      std::cout << \": ERROR[expected fail]\\n\";\n"
      "      return 1;\n"
      "    } else if (expected_result != kSucceed) {\n"
      "      stringstream actual_result;\n"
      "      result->print(actual_result);\n"
      "      if (actual_result.str() != expected_result) {\n"
      "        std::cout << \": ERROR[no match:\\n  expected-> \" << expected_result\n"
      "        << \"\\n  actual->   \" << actual_result.str() << \"\\n  ]\\n\";\n"
      "        return 1;\n"
      "      }\n"
      "    }\n"
      "    std::cout << \"\\n\";\n"
      "    return 0;\n"
      "  } else {\n"
      "    std::cout << \"FAILS\";\n"
      "    if (expected_result == kFail) {\n"
      "      std::cout << \" [as expected]\\n\";\n"
      "      return 0;\n"
      "    } else if (expected_result == kPrint || expected_result == kSucceed) {\n"
      "      std::cout << \": ERROR[expected success]\";\n"
      "    } else {\n"
      "      std::cout << \": ERROR[expected \" << expected_result << \"]\";\n"
      "    }\n"
      "    std::cout << \"\\n  \" << errors.str();\n"
      "    return 1;\n"
      "  }\n"
      "}\n"
      "\n"
      "int ParseSamples() {\n"
      "  int num_errors = 0;\n"
      "/* BEGIN SAMPLES */\n"
      ;
  PrintSampleTests(out);
  out <<
      "/* END SAMPLES */\n"
      "  std::cout << \"Errors: \" << num_errors << \"\\n\";\n"
      "  return num_errors;\n"
      "}\n"
      "\n"
      "#endif  // PARSER_TEST\n"
      "\n"
      "\n"
      "}  // namespace " << NamespaceName() << "\n"
      "\n"
      "#ifdef PARSER_TEST\n"
      "\n"
      "#include <fstream>\n"
      "#include <iostream>\n"
      "#include <memory>\n"
      "\n"
      "using std::istream;\n"
      "using std::ifstream;\n"
      "using std::unique_ptr;\n"
      "\n"
      "const char usage[] = \"usage: " << NamespaceName() << " [input-file | --samples]\\n\";\n"
      "\n"
      "int main(int argc, char** argv) {\n"
      "  if (argc > 2) {\n"
      "    std::cerr << usage;\n"
      "    exit(1);\n"
      "  }\n"
      "  if (std::string(argv[1]) == \"--samples\") {\n"
      "    if (" << NamespaceName() << "::ParseSamples() > 0) exit(1);\n"
      "  } else {\n"
      "    ifstream file;\n"
      "    if (argc == 2) {\n"
      "      file.open(argv[1]);\n"
      "      if (file.fail()) {\n"
      "        std::cerr << \"failed to open '\" << argv[1] << \"' for reading\\n\";\n"
      "        exit(1);\n"
      "      }\n"
      "    }\n"
      "    istream& input = argc == 2 ? file : std::cin;\n"
      "    " << NamespaceName() << "::ParseAndPrint(input, std::cout);\n"
      "  }\n"
      "  return 0;\n"
      "}\n"
      "\n"
      "#endif  // PARSER_TEST\n"
      "\n"
      "/* END PARSER */\n";
}

void ParserBase::PrintLexer(ostream& out) {
  out <<
      "/* BEGIN LEXER */\n"
      "%{\n"
      "\n"
      "#define " << ModuleNameUpper() << "_LEX_CC_\n"
      "\n"
      "#include <memory>\n"
      "#include <string>\n"
      "#include <iostream>\n"
      "#include <sstream>\n"
      "\n"
      "#include \"" << ModuleName() << ".yacc.hh\"\n"
      "\n"
      "namespace " << NamespaceName() << " {\n"
      "\n"
      "class AstNode;\n"
      "class ParseDriver;\n"
      "\n"
      "// ParseDriver initiates a parse and contains the state data used during a\n"
      "// single parsing session (that is, during the parse of one file or string).\n"
      "class ParseDriver : public yyFlexLexer {\n"
      " public:\n"
      "  ParseDriver(std::istream& source, std::ostream& errors);\n"
      "  ~ParseDriver() override;\n"
      "\n"
      "  // A function used by the lexer to report errors.\n"
      "  void Error(const YYParser::location_type& loc, const std::string& msg);\n"
      "  void Error(const std::string& msg);\n"
      "  void Fatal[[noreturn]](const YYParser::location_type& loc,\n"
      "                         const std::string& msg);\n"
      "  void LexerError(const char* msg) override;\n"
      "  void LexerError(const string& msg) { LexerError(msg.c_str()); }\n"
      "\n"
      "  // Flex-generated function to get the next token from input\n"
      "  virtual YYParser::symbol_type NextToken(ParseDriver* parser);\n"
      "\n"
      "  // Unput a char and reset location.\n"
      "  virtual void Unput(char c);\n"
      "\n"
      "  void set_initial_token(YYParser::token_type token) { initial_token_ = token; }\n"
      "\n"
      "  void consume_initial_token(YYParser::token_type* token) {\n"
      "    *token = initial_token_;\n"
      "    initial_token_ = YYParser::token::TOK_EOF;\n"
      "  }\n"
      "\n"
      "  int numErrors() { return num_errors_; }\n"
      "\n"
      " protected:\n"
      "  const YYParser::location_type* location() { return &location_; }\n"
      "\n"
      " private:\n"
      "  std::istream* source_;  // Not owned.\n"
      "  std::ostream& errors_;\n"
      "  int num_errors_ = 0;\n"
      "  YYParser::location_type location_;\n"
      "  std::unique_ptr<std::string> file_name_;\n"
      "  YYParser::token_type initial_token_;\n"
      "  std::stringstream current_token_;  // a string token being built up\n"
      "\n"
      "  // Disallow copy and assign.\n"
      "  ParseDriver(const ParseDriver&) = delete;\n"
      "  void operator=(const ParseDriver&) = delete;\n"
      "};\n"
      "\n"
      "}  // namespace " << NamespaceName() << "\n"
      "\n"
      "using " << NamespaceName() << "::YYParser;\n"
      "\n"
      "#undef YY_DECL\n"
      "#define YY_DECL \\\n"
      "  YYParser::symbol_type " << NamespaceName() << "::ParseDriver::NextToken(" << NamespaceName() << "::ParseDriver* parser)\n"
      "\n"
      "typedef YYParser::token token;\n"
      "\n"
      "#define yylloc location_\n"
      "#define yyterminate() return YYParser::make_TOK_EOF(yylloc)\n"
      "#define YY_USER_ACTION yylloc.columns(yyleng);\n"
      "\n"
      "%}\n"
      "\n"
      "%option 8bit\n"
      "%option batch\n"
      "%option c++\n"
      "%option full\n"
      "%option noyywrap\n"
      "%option yyclass=\"" << NamespaceName() << "::ParseDriver\"\n"
      "\n"
      "%x string_literal\n"
      "%x blank\n"
      "%x comment\n"
      "\n"
      "EOL    \\r\\n|\\n\n"
      "DDIGIT [[:digit:]]\n"
      "ALNUM  [[:alnum:]_]\n"
      "ALPHA  [[:alpha:]_]\n"
      "BLANK  [[:blank:]\\t]\n"
      "\n"
      "DDIGITS  {DDIGIT}(_?{DDIGIT})*\n"
      "EXPONENT {EXP}{SIGN}?{DDIGITS}\n"
      "\n"
      "%%\n"
      "\n"
      "%{\n"
      "  yylloc.step();\n"
      "%}\n"
      "\n"
      "false {\n"
      "    return YYParser::make_TOK_BOOL(false, yylloc);\n"
      "}\n"
      "\n"
      "true {\n"
      "    return YYParser::make_TOK_BOOL(true, yylloc);\n"
      "}\n"
      "\n"
      "  /* BEGIN GENERATED TOKENS */\n"
      ;
  PrintTokenLexers(out);
  out <<
      "  /* END GENERATED TOKENS */\n"
      "\n"
      "<INITIAL><<EOF>>  {\n"
      "    return YYParser::make_TOK_EOF(yylloc);\n"
      "  }\n"
      "\n"
      "'  {\n"
      "    current_token_.str(\"\");\n"
      "    BEGIN(string_literal);\n"
      "}\n"
      "\n"
      "\\/\\/ {\n"
      "    BEGIN(comment);\n"
      "}\n"
      "\n"
      "<string_literal>{\n"
      "\n"
      "  ''  {\n"
      "       current_token_ << '\\'';\n"
      "    }\n"
      "\n"
      "  \\'  {\n"
      "      BEGIN(INITIAL);\n"
      "      return YYParser::make_TOK_STRING_LITERAL(current_token_.str(), yylloc);\n"
      "    }\n"
      "\n"
      "  {EOL}  {\n"
      "      BEGIN(INITIAL);\n"
      "      yylloc.lines(1);\n"
      "      LexerError(\"string not terminated: '\" + current_token_.str() + \"'\");\n"
      "    }\n"
      "\n"
      "  [[:cntrl:]]  {\n"
      "      LexerError(\"unexpected character: \" + std::to_string(YYText()[0]));\n"
      "    }\n"
      "\n"
      "  <<EOF>>  {\n"
      "      BEGIN(INITIAL);\n"
      "      LexerError(\"string not terminated: '\" + current_token_.str() + \"'\");\n"
      "    }\n"
      "\n"
      "  .  {\n"
      "      current_token_ << YYText();\n"
      "    }\n"
      "  }\n"
      "\n"
      "<comment>{\n"
      "  {EOL}  {\n"
      "    BEGIN(INITIAL);\n"
      "    Unput('\\n');\n"
      "  }\n"
      "}\n"
      "\n"
      "{BLANK}+  {\n"
      "  }\n"
      "\n"
      "  /* integer literal */\n"
      "{DDIGITS}  {\n"
      "    return YYParser::make_TOK_INT64(strtol(YYText(), nullptr, 10), yylloc);\n"
      "  }\n"
      "\n"
      "  /* identifier */\n"
      "{ALPHA}(-*{ALNUM})*  {\n"
      "    return YYParser::make_TOK_IDENTIFIER(YYText(), yylloc);\n"
      "  }\n"
      "\n"
      "%%\n"
      "\n"
      "namespace " << NamespaceName() << " {\n"
      "\n"
      "using std::istream;\n"
      "using std::ostream;\n"
      "\n"
      "AstNode* parse(istream& input, ostream& errors) {\n"
      "  ParseDriver parser(input, errors);\n"
      "  AstNode* result = nullptr;\n"
      "  YYParser yyparser(&parser, &result);\n"
      "  if (yyparser.parse() || parser.numErrors() > 0) {\n"
      "    errors << parser.numErrors() << \" errors.\\n\";\n"
      "    return nullptr;\n"
      "  }\n"
      "  return result;\n"
      "}\n"
      "\n"
      "YYParser::symbol_type yylex(ParseDriver* parser) {\n"
      "  return parser->NextToken(parser);\n"
      "}\n"
      "\n"
      "void YYParser::error(const location_type& loc, const std::string& msg) {\n"
      "  parser->Error(loc, msg);\n"
      "}\n"
      "\n"
      "ParseDriver::ParseDriver(std::istream& source, std::ostream& errors)\n"
      "    : yyFlexLexer(&source)\n"
      "    , source_(&source)\n"
      "    , errors_(errors)\n"
      "    , initial_token_(YYParser::token::TOK_EOF) {}\n"
      "\n"
      "ParseDriver::~ParseDriver() {\n"
      "  // This should be done by the parent, but it uses delete, not delete[]...\n"
      "  delete[] yy_state_buf;\n"
      "  yy_state_buf = NULL;\n"
      "\n"
      "  if (yy_start_stack != NULL) {\n"
      "    free(yy_start_stack);\n"
      "    yy_start_stack = NULL;\n"
      "  }\n"
      "}\n"
      "\n"
      "void ParseDriver::Error(\n"
      "    const YYParser::location_type& loc, const std::string& msg) {\n"
      "  errors_ << \"ERROR: \" << loc << \":\" << msg << \"\\n\";\n"
      "  num_errors_++;\n"
      "}\n"
      "\n"
      "void ParseDriver::Error(const std::string& msg) {\n"
      "  errors_ << \"ERROR: \" << msg << \"\\n\";\n"
      "  num_errors_++;\n"
      "}\n"
      "\n"
      "void ParseDriver::Fatal(\n"
      "    const YYParser::location_type& loc, const std::string& msg) {\n"
      "  errors_ << \"FATAL: \" << loc << \":\" << msg << \"\\n\";\n"
      "  exit(1);\n"
      "}\n"
      "\n"
      "void ParseDriver::LexerError(const char* msg) {\n"
      "  Fatal(location_, msg);\n"
      "}\n"
      "\n"
      "void ParseDriver::Unput(char c) {\n"
      "  assert(location_.end.column > 0);\n"
      "  location_.end.column--;\n"
      "  yyunput(c, yytext);\n"
      "}\n"
      "\n"
      "}  // namespace " << NamespaceName() << "\n"
      "/* END LEXER */\n";
}
